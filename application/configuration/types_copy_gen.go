// generated by deep-copy --type config -o ./types_copy_gen.go ./types.go; DO NOT EDIT.

package configuration

// DeepCopy generates a deep copy of config
func (o config) DeepCopy() config {
	var cp config = o
	if o.Kafka.Brokers != nil {
		cp.Kafka.Brokers = make([]string, len(o.Kafka.Brokers))
		copy(cp.Kafka.Brokers, o.Kafka.Brokers)
	}
	if o.Kafka.TopicDetail.ReplicaAssignment != nil {
		cp.Kafka.TopicDetail.ReplicaAssignment = make(map[int32][]int32, len(o.Kafka.TopicDetail.ReplicaAssignment))
		for k4, v4 := range o.Kafka.TopicDetail.ReplicaAssignment {
			var cp_Kafka_TopicDetail_ReplicaAssignment_v4 []int32
			if v4 != nil {
				cp_Kafka_TopicDetail_ReplicaAssignment_v4 = make([]int32, len(v4))
				copy(cp_Kafka_TopicDetail_ReplicaAssignment_v4, v4)
			}
			cp.Kafka.TopicDetail.ReplicaAssignment[k4] = cp_Kafka_TopicDetail_ReplicaAssignment_v4
		}
	}
	if o.Kafka.TopicDetail.ConfigEntries != nil {
		cp.Kafka.TopicDetail.ConfigEntries = make(map[string]*string, len(o.Kafka.TopicDetail.ConfigEntries))
		for k4, v4 := range o.Kafka.TopicDetail.ConfigEntries {
			var cp_Kafka_TopicDetail_ConfigEntries_v4 *string
			if v4 != nil {
				cp_Kafka_TopicDetail_ConfigEntries_v4 = new(string)
				*cp_Kafka_TopicDetail_ConfigEntries_v4 = *v4
			}
			cp.Kafka.TopicDetail.ConfigEntries[k4] = cp_Kafka_TopicDetail_ConfigEntries_v4
		}
	}
	return cp
}
