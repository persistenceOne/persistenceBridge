// generated by deep-copy --type config -o ./types_copy.go ./types.go; DO NOT EDIT.

package configuration

// DeepCopy generates a deep copy of config
func (c config) DeepCopy() config {
	var cp config = c
	if c.Kafka.Brokers != nil {
		cp.Kafka.Brokers = make([]string, len(c.Kafka.Brokers))
		copy(cp.Kafka.Brokers, c.Kafka.Brokers)
	}
	if c.Kafka.TopicDetail.ReplicaAssignment != nil {
		cp.Kafka.TopicDetail.ReplicaAssignment = make(map[int32][]int32, len(c.Kafka.TopicDetail.ReplicaAssignment))
		for k4, v4 := range c.Kafka.TopicDetail.ReplicaAssignment {
			var cp_Kafka_TopicDetail_ReplicaAssignment_v4 []int32
			if v4 != nil {
				cp_Kafka_TopicDetail_ReplicaAssignment_v4 = make([]int32, len(v4))
				copy(cp_Kafka_TopicDetail_ReplicaAssignment_v4, v4)
			}
			cp.Kafka.TopicDetail.ReplicaAssignment[k4] = cp_Kafka_TopicDetail_ReplicaAssignment_v4
		}
	}
	if c.Kafka.TopicDetail.ConfigEntries != nil {
		cp.Kafka.TopicDetail.ConfigEntries = make(map[string]*string, len(c.Kafka.TopicDetail.ConfigEntries))
		for k4, v4 := range c.Kafka.TopicDetail.ConfigEntries {
			var cp_Kafka_TopicDetail_ConfigEntries_v4 *string
			if v4 != nil {
				cp_Kafka_TopicDetail_ConfigEntries_v4 = new(string)
				*cp_Kafka_TopicDetail_ConfigEntries_v4 = *v4
			}
			cp.Kafka.TopicDetail.ConfigEntries[k4] = cp_Kafka_TopicDetail_ConfigEntries_v4
		}
	}
	return cp
}
